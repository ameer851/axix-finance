import React, { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useAuth } from '@/context/AuthContext';
import AccountSummary from '@/components/ui/account-summary';
import ChartCard from '@/components/ui/chart-card';
import { Button } from '@/components/ui/button';
import { DataTable } from '@/components/ui/data-table';
import { Transaction } from '@shared/schema';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
// Using type assertions for other schema types until imports are fixed
type Portfolio = {
  id: string;
  userId: string;
  totalValue: string;
  cashBalance: string;
  investedAmount: string;
  totalProfit: string;
  totalProfitPercentage: string;
  dailyChange: string;
  dailyChangePercentage: string;
  lastUpdated: string;
  isBalanced: boolean;
  assets: any[];
};

type MarketData = {
  symbol: string;
  name: string;
  price: string;
  change: string;
  changePercentage: string;
};

type Goal = {
  id: string;
  name: string;
  targetAmount: string;
  currentAmount: string;
  progress: number;
  targetDate: string;
};
import { Link } from 'wouter';
import InvestmentCalculator from '@/components/InvestmentCalculator';
import { useToast } from '@/hooks/use-toast';
import {
  ArrowDown,
  ArrowUp,
  ArrowLeftRight,
  PieChart,
  ArrowRight,
  TrendingUp,
  Calculator,
  Search,
  X,
  Filter,
  Calendar,
  DollarSign,
  BarChart3,
  Target,
  FileText,
  Bell,
  HelpCircle,
  Percent,
  RefreshCw
} from 'lucide-react';
import { Input } from '@/components/ui/input';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import {
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer
} from 'recharts';
import { formatDate } from '@/lib/utils';
// Card is already imported above
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Calendar as CalendarComponent } from '@/components/ui/calendar';
import { ColumnDef } from "@tanstack/react-table";

const Dashboard: React.FC = () => {
  const { user } = useAuth();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [searchQuery, setSearchQuery] = useState('');
  const [filterType, setFilterType] = useState<string>('all');
  const [filterStatus, setFilterStatus] = useState<string>('all');
  const [dateFrom, setDateFrom] = useState<Date | undefined>();
  const [dateTo, setDateTo] = useState<Date | undefined>();
  const [showFilters, setShowFilters] = useState(false);
  const [activeTab, setActiveTab] = useState('overview');
  const [timeframe, setTimeframe] = useState('month');
  const [showDepositDialog, setShowDepositDialog] = useState(false);
  const [showWithdrawDialog, setShowWithdrawDialog] = useState(false);
  const [showInvestDialog, setShowInvestDialog] = useState(false);
  const [showGoalDialog, setShowGoalDialog] = useState(false);
  const [showSupportDialog, setShowSupportDialog] = useState(false);
  const [depositAmount, setDepositAmount] = useState('');
  const [withdrawAmount, setWithdrawAmount] = useState('');
  const [selectedMarketSymbol, setSelectedMarketSymbol] = useState('');

  // Fetch portfolio data
  const { data: portfolio, isLoading: portfolioLoading } = useQuery({
    queryKey: ['portfolio', user?.id],
    queryFn: async () => {
      try {
        const response = await fetch(`/api/users/${user?.id}/portfolio`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
      } catch (error) {
        console.error('Error fetching portfolio:', error);
        throw error;
      }
    },
    enabled: !!user?.id
  });

  // Fetch market data
  const { data: marketData, isLoading: marketLoading } = useQuery({
    queryKey: ['market-overview'],
    queryFn: async () => {
      try {
        const response = await fetch('/api/market/overview');
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
      } catch (error) {
        console.error('Error fetching market data:', error);
        throw error;
      }
    }
  });

  // Fetch goals data
  const { data: goals = [], isLoading: goalsLoading } = useQuery({
    queryKey: ['goals', user?.id],
    queryFn: async () => {
      try {
        const response = await fetch(`/api/users/${user?.id}/goals`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
      } catch (error) {
        console.error('Error fetching goals:', error);
        throw error;
      }
    },
    enabled: !!user?.id
  });

  // Fetch statements
  const { data: statements = [], isLoading: statementsLoading } = useQuery({
    queryKey: ['statements', user?.id],
    queryFn: async () => {
      try {
        const response = await fetch(`/api/users/${user?.id}/statements`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
      } catch (error) {
        console.error('Error fetching statements:', error);
        throw error;
      }
    },
    enabled: !!user?.id
  });

  // Fetch notifications
  const { data: notifications = [], isLoading: notificationsLoading } = useQuery({
    queryKey: ['notifications', user?.id],
    queryFn: async () => {
      try {
        const response = await fetch(`/api/users/${user?.id}/notifications`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
      } catch (error) {
        console.error('Error fetching notifications:', error);
        throw error;
      }
    },
    enabled: !!user?.id
  });

  // Fetch user transactions with proper error handling
  const { data: transactions = [], error: transactionError } = useQuery({
    queryKey: [`/api/users/${user?.id}/transactions`],
    queryFn: async () => {
      try {
        const response = await fetch(`/api/users/${user?.id}/transactions`);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const contentType = response.headers.get("content-type");
        if (!contentType || !contentType.includes("application/json")) {
          throw new TypeError("Received non-JSON response from server");
        }
        return await response.json();
      } catch (error) {
        console.error('Error fetching transactions:', error);
        throw error;
      }
    },
    enabled: !!user?.id
  });

  // Mutation for deposit action
  const depositMutation = useMutation({
    mutationFn: async (amount: string) => {
      const response = await fetch(`/api/users/${user?.id}/transactions`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: 'deposit',
          amount,
          description: 'Deposit to account',
          currency: 'USD'
        })
      });
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      return await response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/users/${user?.id}/transactions`] });
      queryClient.invalidateQueries({ queryKey: ['portfolio', user?.id] });
      toast({
        title: 'Deposit Successful',
        description: `$${depositAmount} has been added to your account.`
      });
      setShowDepositDialog(false);
      setDepositAmount('');
    },
    onError: (error) => {
      toast({
        title: 'Deposit Failed',
        description: `Error: ${error}`,
        variant: 'destructive'
      });
    }
  });

  // Mutation for withdrawal action
  const withdrawMutation = useMutation({
    mutationFn: async (amount: string) => {
      const response = await fetch(`/api/users/${user?.id}/transactions`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: 'withdrawal',
          amount,
          description: 'Withdrawal from account',
          currency: 'USD'
        })
      });
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      return await response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/users/${user?.id}/transactions`] });
      queryClient.invalidateQueries({ queryKey: ['portfolio', user?.id] });
      toast({
        title: 'Withdrawal Successful',
        description: `$${withdrawAmount} has been withdrawn from your account.`
      });
      setShowWithdrawDialog(false);
      setWithdrawAmount('');
    },
    onError: (error) => {
      toast({
        title: 'Withdrawal Failed',
        description: `Error: ${error}`,
        variant: 'destructive'
      });
    }
  });

  // Mutation for investment action
  const investMutation = useMutation({
    mutationFn: async (data: { symbol: string, amount: string }) => {
      const response = await fetch(`/api/users/${user?.id}/investments`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          symbol: data.symbol,
          amount: data.amount,
          currency: 'USD'
        })
      });
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      return await response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/users/${user?.id}/transactions`] });
      queryClient.invalidateQueries({ queryKey: ['portfolio', user?.id] });
      toast({
        title: 'Investment Successful',
        description: `Your investment has been processed.`
      });
      setShowInvestDialog(false);
    },
    onError: (error) => {
      toast({
        title: 'Investment Failed',
        description: `Error: ${error}`,
        variant: 'destructive'
      });
    }
  });

  // Mutation for creating a goal
  const createGoalMutation = useMutation({
    mutationFn: async (goalData: Partial<Goal>) => {
      const response = await fetch(`/api/users/${user?.id}/goals`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(goalData)
      });
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      return await response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['goals', user?.id] });
      toast({
        title: 'Goal Created',
        description: 'Your investment goal has been created successfully.'
      });
      setShowGoalDialog(false);
    },
    onError: (error) => {
      toast({
        title: 'Goal Creation Failed',
        description: `Error: ${error}`,
        variant: 'destructive'
      });
    }
  });

  // Mutation for creating a support ticket
  const createSupportTicketMutation = useMutation({
    mutationFn: async (data: { subject: string, message: string, priority: string }) => {
      const response = await fetch(`/api/users/${user?.id}/support-tickets`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      return await response.json();
    },
    onSuccess: () => {
      toast({
        title: 'Support Ticket Created',
        description: 'Your support request has been submitted. Our team will respond shortly.'
      });
      setShowSupportDialog(false);
    },
    onError: (error) => {
      toast({
        title: 'Support Request Failed',
        description: `Error: ${error}`,
        variant: 'destructive'
      });
    }
  });

  // Handle deposit submission
  const handleDeposit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!depositAmount || isNaN(Number(depositAmount)) || Number(depositAmount) <= 0) {
      toast({
        title: 'Invalid Amount',
        description: 'Please enter a valid deposit amount.',
        variant: 'destructive'
      });
      return;
    }
    depositMutation.mutate(depositAmount);
  };

  // Handle withdrawal submission
  const handleWithdraw = (e: React.FormEvent) => {
    e.preventDefault();
    if (!withdrawAmount || isNaN(Number(withdrawAmount)) || Number(withdrawAmount) <= 0) {
      toast({
        title: 'Invalid Amount',
        description: 'Please enter a valid withdrawal amount.',
        variant: 'destructive'
      });
      return;
    }
    
    const balance = parseFloat(user?.balance || '0');
    if (Number(withdrawAmount) > balance) {
      toast({
        title: 'Insufficient Funds',
        description: 'You do not have enough funds for this withdrawal.',
        variant: 'destructive'
      });
      return;
    }
    
    withdrawMutation.mutate(withdrawAmount);
  };

  // Format currency
  const formatCurrency = (value: string | number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2
    }).format(typeof value === 'string' ? parseFloat(value) : value);
  };

  // Filter transactions
  const filteredTransactions = transactions.filter((transaction: Transaction) => {
    const matchesSearch = searchQuery === '' || 
      transaction.description?.toLowerCase().includes(searchQuery.toLowerCase()) ||
      transaction.type.toLowerCase().includes(searchQuery.toLowerCase()) ||
      transaction.status.toLowerCase().includes(searchQuery.toLowerCase());
    
    const matchesType = filterType === 'all' || transaction.type === filterType;
    const matchesStatus = filterStatus === 'all' || transaction.status === filterStatus;
    
    // Date filtering
    let matchesDateRange = true;
    if (dateFrom || dateTo) {
      const txDate = new Date(transaction.createdAt || '');
      if (dateFrom && txDate < dateFrom) matchesDateRange = false;
      if (dateTo) {
        // Set time to end of day for the "to" date
        const endOfDay = new Date(dateTo);
        endOfDay.setHours(23, 59, 59, 999);
        if (txDate > endOfDay) matchesDateRange = false;
      }
    }
    
    return matchesSearch && matchesType && matchesStatus && matchesDateRange;
  });

  // Calculate key stats
  const balance = user?.balance || "0";
  const pendingTransactions = transactions.filter((t: Transaction) => t.status === 'pending').length;
  const totalInvested = transactions
    .filter((t: Transaction) => t.type === 'investment' && t.status === 'completed')
    .reduce((sum: number, t: Transaction) => sum + parseFloat(t.amount as string), 0)
    .toFixed(2);
  const totalReturns = transactions
    .filter((t: Transaction) => t.type === 'deposit' && t.status === 'completed')
    .reduce((sum: number, t: Transaction) => sum + parseFloat(t.amount as string), 0)
    .toFixed(2);

  const { isLoading } = useQuery<Transaction[]>({
    queryKey: [`/api/users/${user?.id}/transactions`],
    enabled: !!user?.id,
  });

  const columns: ColumnDef<Transaction>[] = [
    { 
      header: "Date",
      accessorKey: "createdAt",
      cell: ({ row }) => row.getValue("createdAt") ? formatDate(new Date(row.getValue("createdAt") as string)) : 'N/A'
    },
    { 
      header: "Description",
      accessorKey: "description"
    },
    { 
      header: "Type",
      accessorKey: "type",
      cell: ({ row }) => {
        const type = row.getValue("type") as string;
        return (
          <div className="flex items-center">
            {type === 'deposit' && <ArrowDown className="mr-2 h-4 w-4 text-green-500" />}
            {type === 'withdrawal' && <ArrowUp className="mr-2 h-4 w-4 text-red-500" />}
            {type === 'investment' && <TrendingUp className="mr-2 h-4 w-4 text-blue-500" />}
            {type === 'transfer' && <ArrowLeftRight className="mr-2 h-4 w-4 text-purple-500" />}
            {type}
          </div>
        );
      }
    },
    { 
      header: "Amount",
      accessorKey: "amount",
      cell: ({ row }) => {
        const type = row.getValue("type") as string;
        const amount = row.getValue("amount") as string;
        return (
          <span className={type === 'deposit' || type === 'transfer' ? 'text-green-500' : 'text-red-500'}>
            ${amount}
          </span>
        );
      }
    },
    { 
      header: "Status",
      accessorKey: "status",
      cell: ({ row }) => {
        const status = row.getValue("status") as string;
        return (
          <span className={`px-2 py-1 rounded-full text-xs ${
            status === 'completed' ? 'bg-green-100 text-green-800' : 
            status === 'pending' ? 'bg-yellow-100 text-yellow-800' : 
            'bg-red-100 text-red-800'
          }`}>
            {status}
          </span>
        );
      }
    }
  ];

  return (
    <div className="flex flex-col w-full gap-6">
      {/* Quick Action Buttons */}
      <div className="flex flex-wrap gap-2 justify-end">
        <Button onClick={() => setShowDepositDialog(true)}>
          <DollarSign className="h-4 w-4 mr-2" />
          Deposit
        </Button>
        <Button variant="outline" onClick={() => setShowWithdrawDialog(true)}>
          <ArrowUp className="h-4 w-4 mr-2" />
          Withdraw
        </Button>
        <Button variant="outline" onClick={() => setShowInvestDialog(true)}>
          <TrendingUp className="h-4 w-4 mr-2" />
          Invest
        </Button>
        <Button variant="outline" onClick={() => setShowGoalDialog(true)}>
          <Target className="h-4 w-4 mr-2" />
          New Goal
        </Button>
        <Button variant="outline" onClick={() => setShowSupportDialog(true)}>
          <HelpCircle className="h-4 w-4 mr-2" />
          Support
        </Button>
      </div>

      {/* Dashboard Tabs */}
      <Tabs defaultValue={activeTab} value={activeTab} onValueChange={setActiveTab}>
        <TabsList className="grid grid-cols-5 w-full max-w-4xl">
          <TabsTrigger value="overview">
            <PieChart className="h-4 w-4 mr-2" />
            Overview
          </TabsTrigger>
          <TabsTrigger value="transactions">
            <ArrowLeftRight className="h-4 w-4 mr-2" />
            Transactions
          </TabsTrigger>
          <TabsTrigger value="market">
            <BarChart3 className="h-4 w-4 mr-2" />
            Market
          </TabsTrigger>
          <TabsTrigger value="goals">
            <Target className="h-4 w-4 mr-2" />
            Goals
          </TabsTrigger>
          <TabsTrigger value="reports">
            <FileText className="h-4 w-4 mr-2" />
            Reports
          </TabsTrigger>
        </TabsList>

        {/* Overview Tab Content */}
        <TabsContent value="overview" className="space-y-6">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            <AccountSummary 
              title="Total Balance"
              amount={portfolio?.totalValue || balance}
              icon={<PieChart className="h-4 w-4" />}
            />
            <AccountSummary 
              title="Total Invested"
              amount={portfolio?.investedAmount || totalInvested}
              icon={<TrendingUp className="h-4 w-4" />}
            />
            <AccountSummary 
              title="Total Returns"
              amount={portfolio?.totalProfit || totalReturns}
              icon={<ArrowUp className="h-4 w-4" />}
            />
            <AccountSummary 
              title="Pending Transactions"
              amount={pendingTransactions}
              icon={<ArrowLeftRight className="h-4 w-4" />}
            />
          </div>
        </TabsContent>

        {/* Transactions Tab Content */}
        <TabsContent value="transactions" className="space-y-6">
          {/* Advanced Search and Filters */}
          <Card className="p-4">
            <div className="flex flex-col gap-4">
              <div className="flex justify-between items-center">
                <h3 className="text-lg font-semibold">Transaction History</h3>
                <Button 
                  variant="outline" 
                  size="sm"
                  onClick={() => setShowFilters(!showFilters)}
            >
              {showFilters ? <X className="h-4 w-4 mr-2" /> : <Filter className="h-4 w-4 mr-2" />}
              {showFilters ? 'Hide Filters' : 'Show Filters'}
            </Button>
          </div>

          <div className="flex w-full items-center space-x-2">
            <Search className="h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search transactions..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="flex-1"
            />
            {searchQuery && (
              <Button variant="ghost" size="icon" onClick={() => setSearchQuery('')}>
                <X className="h-4 w-4" />
              </Button>
            )}
          </div>

          {showFilters && (
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mt-2">
              <div>
                <Select
                  value={filterType}
                  onValueChange={setFilterType}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Transaction Type" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">All Types</SelectItem>
                    <SelectItem value="deposit">Deposit</SelectItem>
                    <SelectItem value="withdrawal">Withdrawal</SelectItem>
                    <SelectItem value="investment">Investment</SelectItem>
                    <SelectItem value="return">Return</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              
              <div>
                <Select
                  value={filterStatus}
                  onValueChange={setFilterStatus}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Status" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">All Statuses</SelectItem>
                    <SelectItem value="completed">Completed</SelectItem>
                    <SelectItem value="pending">Pending</SelectItem>
                    <SelectItem value="failed">Failed</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              
              <div>
                <Popover>
                  <PopoverTrigger asChild>
                    <Button variant="outline" className="w-full flex justify-between">
                      {dateFrom ? formatDate(dateFrom) : "From Date"}
                      <Calendar className="h-4 w-4 ml-2" />
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0">
                    <CalendarComponent
                      mode="single"
                      selected={dateFrom}
                      onSelect={setDateFrom}
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
              </div>
              
              <div>
                <Popover>
                  <PopoverTrigger asChild>
                    <Button variant="outline" className="w-full flex justify-between">
                      {dateTo ? formatDate(dateTo) : "To Date"}
                      <Calendar className="h-4 w-4 ml-2" />
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0">
                    <CalendarComponent
                      mode="single"
                      selected={dateTo}
                      onSelect={setDateTo}
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
              </div>
            </div>
          )}
        </div>
      </Card>

      {/* Transactions table */}
      <div className="rounded-md border">
        {isLoading ? (
          <div className="flex justify-center items-center h-48">
            <p>Loading transactions...</p>
          </div>
        ) : filteredTransactions.length > 0 ? (
          <DataTable
            columns={columns}
            data={filteredTransactions}
            loading={isLoading}
          />
        ) : (
          <div className="flex flex-col justify-center items-center h-48">
            <p className="text-muted-foreground">No transactions found</p>
            {(searchQuery || filterType !== 'all' || filterStatus !== 'all' || dateFrom || dateTo) && (
              <Button variant="ghost" onClick={() => {
                setSearchQuery('');
                setFilterType('all');
                setFilterStatus('all');
                setDateFrom(undefined);
                setDateTo(undefined);
              }} className="mt-2">
                Clear Filters
              </Button>
            )}
          </div>
        )}
      </div>

      {/* Portfolio Performance */}
      <ChartCard
        title="Portfolio Performance"
        description="Last 30 days activity"
        className="mb-6"
        actions={
          <div className="flex space-x-3">
            {[
              { label: '1W', value: '1w' },
              { label: '1M', value: '1m', selected: true },
              { label: '3M', value: '3m' },
              { label: '1Y', value: '1y' },
              { label: 'All', value: 'all' }
            ].map((option) => (
              <Button
                key={option.value}
                variant={option.selected ? "secondary" : "outline"}
                size="sm"
              >
                {option.label}
              </Button>
            ))}
          </div>
        }
      >
        <div className="h-64 p-4">
          <ResponsiveContainer width="100%" height="100%">
            <AreaChart
              data={[]}
              margin={{ top: 10, right: 30, left: 0, bottom: 0 }}
            >
              <defs>
                <linearGradient id="colorValue" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="5%" stopColor="#3B82F6" stopOpacity={0.8}/>
                  <stop offset="95%" stopColor="#3B82F6" stopOpacity={0}/>
                </linearGradient>
              </defs>
              <XAxis dataKey="date" />
              <YAxis />
              <CartesianGrid strokeDasharray="3 3" />
              <Tooltip />
              <Area type="monotone" dataKey="value" stroke="#3B82F6" fillOpacity={1} fill="url(#colorValue)" />
            </AreaChart>
          </ResponsiveContainer>
        </div>
      </ChartCard>
      
      {/* Investment Calculator */}
      <div className="mb-6">
        <InvestmentCalculator />
      </div>
    </div>
  );
};

export default Dashboard;
