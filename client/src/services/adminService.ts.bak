import { apiRequest } from "@/lib/queryClient";
import { 
  AdminDashboardStats, 
  SystemHealth, 
  SystemSettings, 
  AuditLog,
  AdminPasswordUpdate,
  PaginatedResponse,
  TransactionFilters 
} from "@/types/admin";
import { User } from "@/types/user";
import { Transaction } from "@/types/transaction";

// Types
interface BulkActionPayload {
  ids: string[];
  action: 'approve' | 'reject' | 'delete';
  type: 'deposits' | 'withdrawals' | 'transactions';
}

interface ErrorResponse {
  message: string;
  code?: string;
  details?: Record<string, any>;
}

const rateLimiter = new RateLimiter();

// Add a simple delay function for handling rate limits
const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

// Cache for frequently accessed data
const cache = new Map<string, { data: any; timestamp: number; ttl: number }>();

function getCachedData(key: string): any | null {
  const cached = cache.get(key);
  if (!cached) return null;

  if (Date.now() - cached.timestamp > cached.ttl) {
    cache.delete(key);
    return null;
  }

  return cached.data;
}

function setCachedData(key: string, data: any, ttl = 30000): void {
  // 30 seconds default TTL
  cache.set(key, { data, timestamp: Date.now(), ttl });
}

// Clear cache function for debugging
function clearCache(): void {
  cache.clear();
  console.log("Admin service cache cleared");
}

// Export cache management functions
export { clearCache };

// Admin Dashboard Statistics
export interface AdminStats {
  totalUsers: number;
  activeUsers: number;
  totalDeposits: number;
  totalWithdrawals: number;
  pendingTransactions: number;
  maintenanceMode: boolean;
  deposits?: {
    total: number;
    pending: number;
    approved: number;
    thisMonth: number;
  };
}

// Filter and pagination options
interface FilterOptions {
  status?: string;
  userId?: string;
  startDate?: string;
  endDate?: string;
  type?: string;
  searchTerm?: string;
}

interface PaginationOptions {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

// Admin service interface
interface AdminService {
  getDashboardStats: () => Promise<AdminDashboardStats>;
  getSystemHealth: () => Promise<SystemHealth>;
  getSettings: () => Promise<SystemSettings>;
  updateSettings: (settings: Record<string, any>) => Promise<SystemSettings>;
  getUsers: (filters: FilterOptions & PaginationOptions) => Promise<PaginatedResponse<User>>;
  getTransactions: (filters: TransactionFilters) => Promise<PaginatedResponse<Transaction>>;
  getAuditLogs: (filters: FilterOptions & PaginationOptions) => Promise<PaginatedResponse<AuditLog>>;
  updateAdminPassword: (data: AdminPasswordUpdate) => Promise<void>;
}

/**
 * Admin service for handling all admin panel operations.
 */
export const adminService = {
  getDashboardStats: async (): Promise<AdminDashboardStats> => {
    try {
      const response = await apiRequest.get<AdminDashboardStats>('/api/admin/stats');
      return response.data;
    } catch (error) {
      throw new Error('Failed to fetch dashboard stats');
    }
  },

  getSystemHealth: async (): Promise<SystemHealth> => {
    try {
      const response = await apiRequest.get<SystemHealth>('/api/admin/health');
      return response.data;
    } catch (error) {
      throw new Error('Failed to fetch system health');
    }
  },

  getSystemSettings: async (): Promise<SystemSettings> => {
    try {
      const response = await apiRequest.get<SystemSettings>('/api/admin/settings');
      return response.data;
    } catch (error) {
      throw new Error('Failed to fetch system settings');
    }
  },

  updateSystemSettings: async (settings: Partial<SystemSettings>): Promise<SystemSettings> => {
    try {
      const response = await apiRequest.post<SystemSettings>('/api/admin/settings', settings);
      return response.data;
    } catch (error) {
      throw new Error('Failed to update system settings');
    }
  },

  getUsers: async (filters?: Partial<TransactionFilters>): Promise<PaginatedResponse<User>> => {
    try {
      const response = await apiRequest.get<PaginatedResponse<User>>('/api/admin/users', { params: filters });
      return response.data;
    } catch (error) {
      throw new Error('Failed to fetch users');
    }
  },

  getTransactions: async (filters?: Partial<TransactionFilters>): Promise<PaginatedResponse<Transaction>> => {
    try {
      const response = await apiRequest.get<PaginatedResponse<Transaction>>('/api/admin/transactions', { params: filters });
      return response.data;
    } catch (error) {
      throw new Error('Failed to fetch transactions');
    }
  },

  getAuditLogs: async (filters?: Partial<TransactionFilters>): Promise<PaginatedResponse<AuditLog>> => {
    try {
      const response = await apiRequest.get<PaginatedResponse<AuditLog>>('/api/admin/audit-logs', { params: filters });
      return response.data;
    } catch (error) {
      throw new Error('Failed to fetch audit logs');
    }
  },

  updateAdminPassword: async (data: AdminPasswordUpdate): Promise<void> => {
    try {
      await apiRequest.post('/api/admin/password', data);
    } catch (error) {
      throw new Error('Failed to update admin password');
    }
  },

  bulkAction: async (payload: BulkActionPayload): Promise<void> => {
    try {
      await apiRequest.post('/api/admin/bulk-action', payload);
    } catch (error) {
      throw new Error('Failed to perform bulk action');
    }
  }
} as const;

export default adminService;
  id: number;
  username: string;
  email: string;
  firstName: string;
  lastName: string;
  role: string;
  isActive: boolean;
  isVerified: boolean;
  balance: number;
  createdAt: string;
  updatedAt: string;
}

export default adminService;

// Admin Dashboard Services
export const adminService = {
  // Dashboard Stats with caching (temporarily disabled rate limiting for debugging)
  getStats: async (): Promise<AdminStats> => {
    const cacheKey = "admin-stats";

    // Check cache first
    const cachedStats = getCachedData(cacheKey);
    if (cachedStats) {
      return cachedStats;
    }

    try {
      const response = await apiRequest("GET", "/api/admin/stats-simple");
      const data = await safelyParseJSON(response, "Admin stats");

      // Cache the result for 30 seconds
      setCachedData(cacheKey, data, 30000);

      return data;
    } catch (error: any) {
      console.error("Admin stats error:", error);
      if (error.message.includes("429")) {
        throw new Error(
          "Too many requests. Please wait a moment before refreshing."
        );
      }
      if (error.message.includes("Authentication required")) {
        throw error;
      }
      throw new Error(
        "Failed to load admin statistics. Please check your connection and try again."
      );
    }
  },

  // User Management
  getUsers: async (filters: FilterOptions & PaginationOptions = {}) => {
    try {
      // Use the simplified admin users endpoint that works with Supabase
      const response = await apiRequest("GET", `/api/admin/users-simple`);
      const data = await safelyParseJSON(response, "Admin users");

      // Apply filters client-side for now
      let users = data.users || [];

      // Apply filters if provided
      if (filters.status && filters.status !== "all") {
        users = users.filter((user: any) => {
          if (filters.status === "active") return user.is_active;
          if (filters.status === "inactive") return !user.is_active;
          return true;
        });
      }

      if (filters.search) {
        const searchLower = filters.search.toLowerCase();
        users = users.filter(
          (user: any) =>
            user.username?.toLowerCase().includes(searchLower) ||
            user.email?.toLowerCase().includes(searchLower) ||
            user.first_name?.toLowerCase().includes(searchLower) ||
            user.last_name?.toLowerCase().includes(searchLower)
        );
      }

      // Apply pagination client-side
      const page = filters.page || 1;
      const limit = filters.limit || 50;
      const startIndex = (page - 1) * limit;
      const endIndex = startIndex + limit;

      return {
        users: users.slice(startIndex, endIndex),
        total: users.length,
        page,
        totalPages: Math.ceil(users.length / limit),
      };
    } catch (error) {
      console.error("Error fetching users:", error);
      throw error;
    }
  },

  updateUser: async (userId: number, updates: Partial<AdminUser>) => {
    const response = await apiRequest(
      "PUT",
      `/api/admin/users/${userId}`,
      updates
    );
    return await response.json();
  },

  deleteUser: async (userId: number) => {
    const response = await apiRequest("DELETE", `/api/admin/users/${userId}`);
    return await response.json();
  },

  // Bulk User Operations
  bulkUpdateUsers: async (userIds: number[], updates: Partial<AdminUser>) => {
    const response = await apiRequest("POST", "/api/admin/users/bulk-update", {
      userIds,
      updates,
    });
    return await response.json();
  },

  // Deposit Management with caching (temporarily disabled rate limiting for debugging)
  getDeposits: async (filters: FilterOptions & PaginationOptions = {}) => {
    const cacheKey = `admin-deposits-${JSON.stringify(filters)}`;

    // Check cache first (shorter TTL for dynamic data)
    const cachedDeposits = getCachedData(cacheKey);
    if (cachedDeposits) {
      return cachedDeposits;
    }

    try {
      const params = new URLSearchParams();
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== undefined && value !== "") {
          params.append(key, value.toString());
        }
      });

      const response = await apiRequest(
        "GET",
        `/api/admin/transactions?${params}`
      );

      if (!response.ok) {
        throw new Error(`Failed to fetch deposits: ${response.status}`);
      }

      const data = await response.json();
      
      const result = {
        deposits: data.transactions || [],
        totalPages: data.totalPages || 1,
        currentPage: data.page || 1,
        totalDeposits: data.total || 0
      };

      // Cache for 15 seconds (shorter for transaction data)
      setCachedData(cacheKey, result, 15000);

      return result;
      } catch (parseError) {
        console.error("JSON parse error:", parseError, "Response text:", text);
        throw new Error("Invalid response format from server");
      }
    } catch (error: any) {
      console.error("Error fetching deposits:", error);
      if (error.message.includes("429")) {
        throw new Error(
          "Too many requests. Please wait a moment before refreshing."
        );
      }
      throw error;
    }
  },

  updateDeposit: async (depositId: string, updates: Partial<AdminDeposit>) => {
    const response = await apiRequest(
      "PUT",
      `/api/admin/deposits/${depositId}`,
      updates
    );
    return await response.json();
  },

  deleteDeposit: async (depositId: string) => {
    const response = await apiRequest(
      "DELETE",
      `/api/admin/deposits/${depositId}`
    );
    return await response.json();
  },

  updateWithdrawal: async (
    withdrawalId: string,
    updates: Partial<AdminWithdrawal>
  ) => {
    const response = await apiRequest(
      "PUT",
      `/api/admin/withdrawals/${withdrawalId}`,
      updates
    );
    return await response.json();
  },

  deleteWithdrawal: async (withdrawalId: string) => {
    const response = await apiRequest(
      "DELETE",
      `/api/admin/withdrawals/${withdrawalId}`
    );
    return await response.json();
  },

  // Generic bulk actions
  bulkAction: async (
    type: "deposits" | "withdrawals" | "users",
    action: string,
    ids: string[]
  ) => {
    const response = await apiRequest(
      "POST",
      `/api/admin/${type}/bulk-${action}`,
      {
        [`${type.slice(0, -1)}Ids`]: ids, // Convert 'deposits' to 'depositIds', etc.
      }
    );
    return await response.json();
  },

  // Settings shortcuts
  getSettings: async () => {
    return adminService.getSystemSettings();
  },

  updateSettings: async (settings: Record<string, any>) => {
    return adminService.updateSystemSettings(settings);
  },

  updateDepositStatus: async (
    depositId: string,
    status: string,
    reason?: string
  ) => {
    const response = await apiRequest(
      "PUT",
      `/api/admin/deposits/${depositId}/status`,
      {
        status,
        reason,
      }
    );
    return await response.json();
  },

  bulkApproveDeposits: async (depositIds: string[]) => {
    const response = await apiRequest(
      "POST",
      "/api/admin/deposits/bulk-approve",
      {
        depositIds,
      }
    );
    return await response.json();
  },

  bulkRejectDeposits: async (depositIds: string[]) => {
    const response = await apiRequest(
      "POST",
      "/api/admin/deposits/bulk-reject",
      {
        depositIds,
      }
    );
    return await response.json();
  },

  bulkDeleteDeposits: async (depositIds: string[]) => {
    const response = await apiRequest(
      "DELETE",
      "/api/admin/deposits/bulk-delete",
      {
        depositIds,
      }
    );
    return await response.json();
  },

  // Withdrawal Management
  getWithdrawals: async (filters: FilterOptions & PaginationOptions = {}) => {
    const params = new URLSearchParams();
    
    // Always filter for withdrawal type transactions
    params.append('type', 'withdrawal');
    
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== "") {
        params.append(key, value.toString());
      }
    });

    try {
      const response = await apiRequest(
        "GET",
        `/api/admin/transactions?${params}`
      );
      
      if (!response.ok) {
        throw new Error(`Failed to fetch withdrawals: ${response.status}`);
      }
      
      const data = await response.json();
      
      return {
        withdrawals: data.transactions || [],
        totalWithdrawals: data.total || 0,
        currentPage: data.page || 1,
        totalPages: data.totalPages || 1
      };
    } catch (error) {
      console.error("Error fetching withdrawals:", error);
      throw error;
    }
  },

  updateWithdrawalStatus: async (
    withdrawalId: string,
    status: string,
    reason?: string
  ) => {
    const response = await apiRequest(
      "PUT",
      `/api/admin/withdrawals/${withdrawalId}/status`,
      {
        status,
        reason,
      }
    );
    return await response.json();
  },

  createTestWithdrawal: async () => {
    try {
      // Create a test withdrawal for demonstration purposes
      const response = await apiRequest("POST", `/api/transactions`, {
        type: "withdrawal",
        amount: 500,
        method: "Bank Transfer",
        wallet_address: null,
      });
      return await response.json();
    } catch (error) {
      console.error("Failed to create test withdrawal:", error);
      throw error;
    }
  },

  bulkApproveWithdrawals: async (withdrawalIds: string[]) => {
    const response = await apiRequest(
      "POST",
      "/api/admin/withdrawals/bulk-approve",
      {
        withdrawalIds,
      }
    );
    return await response.json();
  },

  bulkRejectWithdrawals: async (withdrawalIds: string[]) => {
    const response = await apiRequest(
      "POST",
      "/api/admin/withdrawals/bulk-reject",
      {
        withdrawalIds,
      }
    );
    return await response.json();
  },

  // Transaction Management
  getTransactions: async (filters: FilterOptions & PaginationOptions = {}) => {
    const params = new URLSearchParams();
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== "") {
        params.append(key, value.toString());
      }
    });

    const response = await apiRequest(
      "GET",
      `/api/admin/transactions?${params}`
    );
    return await response.json();
  },

  updateTransactionStatus: async (
    transactionId: string,
    status: string,
    reason?: string
  ) => {
    const response = await apiRequest(
      "PUT",
      `/api/admin/transactions/${transactionId}/status`,
      {
        status,
        reason,
      }
    );
    return await response.json();
  },

  bulkUpdateTransactions: async (
    transactionIds: string[],
    status: string,
    reason?: string
  ) => {
    const response = await apiRequest(
      "POST",
      "/api/admin/transactions/bulk-update",
      {
        transactionIds,
        status,
        reason,
      }
    );
    return await response.json();
  },

  // Settings Management
  getSystemSettings: async () => {
    const response = await apiRequest("GET", "/api/admin/settings");
    return await response.json();
  },

  updateSystemSettings: async (settings: Record<string, any>) => {
    const response = await apiRequest("PUT", "/api/admin/settings", settings);
    return await response.json();
  },

  // Maintenance Management
  getMaintenanceSettings: async () => {
    const response = await apiRequest("GET", "/api/admin/maintenance");
    return await response.json();
  },

  updateMaintenanceSettings: async (settings: Record<string, any>) => {
    const response = await apiRequest(
      "PUT",
      "/api/admin/maintenance",
      settings
    );
    return await response.json();
  },

  toggleMaintenanceMode: async (enabled: boolean) => {
    const response = await apiRequest("PUT", "/api/admin/maintenance", {
      enabled,
    });
    return await response.json();
  },

  // Audit Logs
  getAuditLogs: async (filters: FilterOptions & PaginationOptions = {}) => {
    const params = new URLSearchParams();
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== "") {
        params.append(key, value.toString());
      }
    });

    const response = await apiRequest(
      "GET",
      `/api/admin/audit-logs-simple?${params}`
    );
    return await response.json();
  },

  // Export Functions
  exportUsers: async (format: "csv" | "pdf" = "csv") => {
    const response = await apiRequest(
      "GET",
      `/api/admin/export/users?format=${format}`
    );
    return response; // Return response directly for download handling
  },

  exportTransactions: async (
    format: "csv" | "pdf" = "csv",
    filters: FilterOptions = {}
  ) => {
    const params = new URLSearchParams({ format });
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== "") {
        params.append(key, value.toString());
      }
    });

    const response = await apiRequest(
      "GET",
      `/api/admin/export/transactions?${params}`
    );
    return response; // Return response directly for download handling
  },

  // Admin Password Management
  updateAdminPassword: async (
    currentPassword: string,
    newPassword: string,
    confirmPassword: string
  ) => {
    const response = await apiRequest("POST", "/api/admin/update-password", {
      currentPassword,
      newPassword,
      confirmPassword,
    });
    return await response.json();
  },

  // Individual Deposit Actions
  approveDeposit: async (id: number) => {
    const response = await apiRequest(
      "POST",
      `/api/admin/deposits/${id}/approve`
    );
    return await response.json();
  },

  rejectDeposit: async (id: number) => {
    const response = await apiRequest(
      "POST",
      `/api/admin/deposits/${id}/reject`
    );
    return await response.json();
  },

  // Individual Withdrawal Actions
  approveWithdrawal: async (id: number) => {
    const response = await apiRequest(
      "POST",
      `/api/admin/withdrawals/${id}/approve`
    );
    return await response.json();
  },

  rejectWithdrawal: async (id: number) => {
    const response = await apiRequest(
      "POST",
      `/api/admin/withdrawals/${id}/reject`
    );
    return await response.json();
  },

  // Bulk Delete Withdrawals
  bulkDeleteWithdrawals: async (ids: string[]) => {
    const response = await apiRequest(
      "POST",
      "/api/admin/withdrawals/bulk-delete",
      { ids }
    );
    return await response.json();
  },

  // System Health
  getSystemHealth: async () => {
    const response = await apiRequest("GET", "/health");
    return await response.json();
  },

  // Dashboard Quick Actions
  processPendingTransactions: async () => {
    const response = await apiRequest("POST", "/api/admin/process-pending");
    return await response.json();
  },

  generateReports: async (type: string, filters: Record<string, any> = {}) => {
    const response = await apiRequest("POST", "/api/admin/generate-report", {
      type,
      filters,
    });
    return await response.json();
  },
};

export default adminService;
